{
  parserClass='org.ice1000.julia.lang.JuliaParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Julia'
  psiImplClassSuffix='Impl'
  psiPackage='org.ice1000.julia.lang.psi'
  psiImplPackage='org.ice1000.julia.lang.psi.impl'

  tokenTypeClass='org.ice1000.julia.lang.JuliaTokenType'
  elementTypeHolderClass='org.ice1000.julia.lang.psi.JuliaTypes'
  elementTypeClass='org.ice1000.julia.lang.JuliaElementType'
  psiImplUtilClass='org.ice1000.julia.lang.psi.impl.JuliaPsiImplUtils'
}

juliaFile ::= statements

macroIdentifier ::= AT_SYM identifier
symbol ::= SYM
identifier ::=
   (symbol  (endOfLine DOT_SYM endOfLine symbol)*)
 | (symbol? (endOfLine DOT_SYM endOfLine symbol)+)

//noinspection BnfUnusedRule
comment ::= LINE_COMMENT | BLOCK_COMMENT
string ::= STR | RAW_STR
integer ::= INT_LITERAL
float ::= FLOAT_LITERAL
boolean ::= TRUE_KEYWORD | FALSE_KEYWORD
// char ::= CHAR_LITERAL

private endOfLine ::= EOL?
private semi ::= EOL | SEMICOLON_SYM
statements ::= semi* (statement (semi+ statement)*)? semi*
private statement ::=
   includeStatement
 | moduleDeclaration
 | exportStatement
 | importStatement
 | usingStatement
 | tryCatchStatement
 | returnStatement
 | breakStatement
 | continueStatement
 | typeDeclaration
 | expr

breakStatement ::= BREAK_KEYWORD
continueStatement ::= CONTINUE_KEYWORD
includeStatement ::=
 INCLUDE_KEYWORD endOfLine
  LEFT_BRACKET endOfLine
   string endOfLine
  RIGHT_BRACKET

exportStatement ::=
 EXPORT_KEYWORD endOfLine
  (identifier | macroIdentifier)
  (endOfLine COMMA_SYM endOfLine
   (identifier | macroIdentifier))*

importStatement ::=
 IMPORT_KEYWORD endOfLine
  identifier endOfLine
  (COLON_SYM endOfLine
   identifier
   (
    endOfLine
    COMMA_SYM endOfLine
    identifier
   )*
  )?

usingStatement ::=
 USING_KEYWORD endOfLine
  identifier? (endOfLine COMMA_SYM endOfLine identifier)*

if ::=
 IF_KEYWORD statements
  elseIfClause*
  elseClause?
 END_KEYWORD

elseIfClause ::= ELSEIF_KEYWORD statements
elseClause ::= ELSE_KEYWORD statements

for ::= indexer statements END_KEYWORD
private indexer ::= FOR_KEYWORD endOfLine (multiIndexer | singleIndexer)
singleIndexer ::= symbol (IN_KEYWORD | EQ_SYM) endOfLine expr
multiIndexer ::=
 LEFT_BRACKET endOfLine
  symbol (endOfLine COMMA_SYM endOfLine symbol)+ endOfLine
 RIGHT_BRACKET
 (IN_KEYWORD | EQ_SYM) endOfLine
 expr

while ::=
 WHILE_KEYWORD endOfLine
  expr endOfLine
   statements
 END_KEYWORD

returnStatement ::= RETURN_KEYWORD expr?
tryCatchStatement ::=
 TRY_KEYWORD endOfLine
  statements
 catchClause?
 finallyClause?
 END_KEYWORD

catchClause ::=
 CATCH_KEYWORD symbol? endOfLine
 statements

finallyClause ::=
 FINALLY_KEYWORD statements

moduleType ::= BAREMODULE_KEYWORD | MODULE_KEYWORD
moduleDeclaration ::=
 moduleType identifier endOfLine
  statements
 END_KEYWORD

private variables ::=
 LEFT_BRACKET endOfLine
  (typedVariable (endOfLine COMMA_SYM endOfLine typedVariable)*)? endOfLine
 RIGHT_BRACKET

function ::=
 FUNCTION_KEYWORD endOfLine
    identifier endOfLine
     typeParameters? endOfLine
   variables type? endOfLine
  statements
 END_KEYWORD

functionName ::= SYM
compactFunction ::=
 functionName endOfLine
  typeParameters?
   variables EQ_SYM endOfLine
 statement

typeName ::= SYM
typeDeclaration ::=
 typeAndAbsTypeKeywords endOfLine
   typeName endOfLine (SUBTYPE_SYM endOfLine identifier)?
  (assignmentExpression endOfLine)*
  function*
 END_KEYWORD

expr ::=
   string
 | integer
 | float
 | boolean
 | identifier
 | if
 | for
 | while
 | function
 | compactFunction

assignmentExpression ::= 'TODO'

// | char
type ::= DOUBLE_COLON endOfLine identifier
typedVariable ::=
 identifier endOfLine
  type? endOfLine
 typeParameters?

typeParameters ::=
 LEFT_B_BRACKET endOfLine
  expr (endOfLine COMMA_SYM endOfLine expr?)* endOfLine
 RIGHT_B_BRACKET

// class keywords->  `abstract type` and `type`.
// `abstract classname` is deprecated
// and you should use `abstract classname
// end`
typeAndAbsTypeKeywords ::= ABSTRACT_KEYWORD? TYPE_KEYWORD
