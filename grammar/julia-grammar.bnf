{
  // ref: https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm
  parserClass='org.ice1000.julia.lang.JuliaParser'
  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'
  psiClassPrefix='Julia'
  psiImplClassSuffix='Impl'
  psiPackage='org.ice1000.julia.lang.psi'
  psiImplPackage='org.ice1000.julia.lang.psi.impl'

  extends('.*Op')=expr

  tokenTypeClass='org.ice1000.julia.lang.JuliaTokenType'
  elementTypeHolderClass='org.ice1000.julia.lang.psi.JuliaTypes'
  elementTypeClass='org.ice1000.julia.lang.JuliaElementType'
  psiImplUtilClass='org.ice1000.julia.lang.psi.impl.JuliaPsiImplUtils'
}

juliaFile ::= endOfLine statements

macroIdentifier ::= AT_SYM identifier { extends=expr }
symbol ::= SYM { extends=expr }
identifier ::= identifierImpl { extends=expr }
private identifierChain ::= endOfLine DOT_SYM endOfLine symbol
private identifierImpl ::= (symbol identifierChain*) | (symbol? identifierChain+)

private comment ::= BLOCK_COMMENT | LINE_COMMENT
string ::= STR | RAW_STR { extends=expr }
integer ::= INT_LITERAL { extends=expr }
floatLit ::= FLOAT_LITERAL | FLOAT_CONSTANT { extends=expr }
booleanLit ::= TRUE_KEYWORD | FALSE_KEYWORD { extends=expr }
charLit ::= CHAR_LITERAL { extends=expr }
regex ::= REGEX_LITERAL { extends=expr }
byteArray ::= BYTE_ARRAY_LITERAL { extends=expr }

private endOfLineImpl ::= EOL | comment
private endOfLine ::= endOfLineImpl*
private semi ::= endOfLineImpl | SEMICOLON_SYM
statements ::= semi* (statement (semi+ statement)*)? semi*

private statement ::=
   includeStatement
 | moduleDeclaration
 | exportStatement
 | importStatement
 | usingStatement
 | tryCatchStatement
 | returnStatement
 | breakStatement
 | continueStatement
 | expr

breakStatement ::= BREAK_KEYWORD
continueStatement ::= CONTINUE_KEYWORD
includeStatement ::=
 INCLUDE_KEYWORD endOfLine
  LEFT_BRACKET endOfLine
   string endOfLine
  RIGHT_BRACKET

exportStatement ::=
 EXPORT_KEYWORD endOfLine
  (identifier | macroIdentifier)
  (endOfLine COMMA_SYM endOfLine
   (identifier | macroIdentifier))*

importStatement ::=
 IMPORT_KEYWORD endOfLine
  identifier endOfLine
  (COLON_SYM endOfLine
   identifier
   (
    endOfLine
    COMMA_SYM endOfLine
    identifier
   )*
  )?

usingStatement ::=
 USING_KEYWORD endOfLine
  identifier? (endOfLine COMMA_SYM endOfLine identifier)*

ifExpr ::=
 IF_KEYWORD statements
  elseIfClause*
  elseClause?
 END_KEYWORD { extends=expr }

elseIfClause ::= ELSEIF_KEYWORD statements
elseClause ::= ELSE_KEYWORD statements

forExpr ::= indexer statements END_KEYWORD { extends=expr }
private indexer ::= FOR_KEYWORD endOfLine (multiIndexer | singleIndexer)
singleIndexer ::= symbol (IN_KEYWORD | EQ_SYM) endOfLine expr
multiIndexer ::=
 LEFT_BRACKET endOfLine
  symbol (endOfLine COMMA_SYM endOfLine symbol)+ endOfLine
 RIGHT_BRACKET
 (IN_KEYWORD | EQ_SYM) endOfLine
 expr

whileExpr ::=
 WHILE_KEYWORD endOfLine
  expr endOfLine
   statements
 END_KEYWORD { extends=expr }

returnStatement ::= RETURN_KEYWORD expr?
tryCatchStatement ::=
 TRY_KEYWORD endOfLine
  statements
 catchClause?
 finallyClause?
 END_KEYWORD

catchClause ::=
 CATCH_KEYWORD symbol? endOfLine
 statements

finallyClause ::=
 FINALLY_KEYWORD statements

moduleType ::= BAREMODULE_KEYWORD | MODULE_KEYWORD
moduleName ::= identifierImpl
moduleDeclaration ::=
 moduleType moduleName endOfLine
  statements
 END_KEYWORD

union ::= UNION_KEYWORD tuple { extends=expr }
tuple ::=
 LEFT_BRACKET endOfLine
  expr (endOfLine COMMA_SYM endOfLine expr)+ endOfLine COMMA_SYM? endOfLine
 RIGHT_BRACKET { extends=expr }

private variables ::=
 LEFT_BRACKET endOfLine
  (typedVariable (endOfLine COMMA_SYM endOfLine typedVariable)*)? endOfLine
 RIGHT_BRACKET

functionName ::= SYM
function ::=
 FUNCTION_KEYWORD endOfLine
    functionName endOfLine
     (typeParameters endOfLine)?
   variables typeAnnotation? endOfLine
  statements
 END_KEYWORD { extends=expr }

compactFunction ::=
 functionName endOfLine
  (typeParameters endOfLine)?
   variables EQ_SYM endOfLine
 expr { extends=expr }

typeName ::= identifierImpl
abstractTypeName ::= identifierImpl
typeDeclaration ::=
 typeModifiers TYPE_KEYWORD endOfLine
  typeName endOfLine (SUBTYPE_SYM endOfLine identifier)? endOfLine
  (
   ( assignment
   | function
   | compactFunction
   | identifier
   )
   endOfLine
  )*
 END_KEYWORD { extends=expr }

abstractTypeDeclaration ::=
 ABSTRACT_KEYWORD TYPE_KEYWORD endOfLine
  abstractTypeName endOfLine (SUBTYPE_SYM endOfLine identifier)? endOfLine
 END_KEYWORD { extends=expr }

macro ::= 'TODO' { extends=expr }

block ::=
 BLOCK_KEYWORD
  statements
 END_KEYWORD { extends=expr }

assignment ::=
 typedVariable endOfLine
 (
  EQ_SYM endOfLine
  expr
 )?

typeAnnotation ::= DOUBLE_COLON endOfLine identifier
typedVariable ::=
 identifier endOfLine
  (typeAnnotation endOfLine)?
 typeParameters?

typeParameters ::=
 LEFT_B_BRACKET endOfLine
  expr (endOfLine COMMA_SYM endOfLine expr?)* endOfLine
 RIGHT_B_BRACKET

userType ::= identifier typeParameters?
typeModifiers ::= IMMUTABLE_KEYWORD?
typeAlias ::= TYPEALIAS_KEYWORD typeName typeParameters? userType { extends=expr }

expr ::=
   level1
 | ternaryOp
 | level3
 | andOp
 | lambda
 | level6
 | pipeOp
 | level8
 | level9
 | level10
 | level11
 | fractionOp
 | exponentOp
 | typeOp
 | level15
 | primaryExpr

private level1 ::=
   assignOp
 | remainderAssignOp
 | plusAssignOp
 | minusAssignOp
 | multiplyAssignOp
 | fractionAssignOp
 | divideAssignOp
 | factoriseAssignOp
 | exponentAssignOp
 | ushrAssignOp
 | shlAssignOp
 | shrAssignOp
 | inverseDivAssignOp
 | bitwiseAndAssignOp
 | bitwiseOrAssignOp
 | bitwiseXorAssignOp
 | bitWiseNotOp

bitWiseNotOp ::= BITWISE_NOT_SYM expr
bitwiseAndAssignOp ::= expr BITWISE_AND_ASSIGN_SYM expr { rightAssociative=true }
bitwiseOrAssignOp ::= expr BITWISE_OR_ASSIGN_SYM expr { rightAssociative=true }
bitwiseXorAssignOp ::= expr BITWISE_XOR_ASSIGN_SYM expr { rightAssociative=true }
inverseDivAssignOp ::= expr INVERSE_DIV_ASSIGN_SYM expr
shlAssignOp ::= expr SHL_ASSIGN_SYM expr { rightAssociative=true }
shrAssignOp ::= expr SHR_ASSIGN_SYM expr { rightAssociative=true }
assignOp ::= expr EQ_SYM expr { rightAssociative=true }
remainderAssignOp ::= expr REMAINDER_ASSIGN_SYM expr
ushrAssignOp ::= expr USHR_ASSIGN_SYM expr
plusAssignOp ::= expr PLUS_ASSIGN_SYM expr
minusAssignOp ::= expr MINUS_ASSIGN_SYM expr
multiplyAssignOp ::= expr MULTIPLY_ASSIGN_SYM expr
fractionAssignOp ::= expr FRACTION_ASSIGN_SYM expr
divideAssignOp ::= expr DIVIDE_ASSIGN_SYM expr { rightAssociative=true }
factoriseAssignOp ::= expr FACTORISE_ASSIGN_SYM expr { rightAssociative=true }
exponentAssignOp ::= expr EXPONENT_ASSIGN_SYM expr { rightAssociative=true }

// ? :
// level 2
ternaryOp ::= expr QUESTION_SYM expr COLON_SYM expr { extends=expr }

private level3 ::=
   orOp
 | bitwiseOrOp

orOp ::= expr OR_SYM expr
bitwiseOrOp ::= expr BITWISE_OR_SYM expr

// &&
// level 4
andOp ::= expr AND_SYM expr

// ->
// level 5
lambda ::= symbol LAMBDA_ABSTRACTION expr {
	rightAssociative=true
	extends=expr
}

private level6 ::=
   lessThanOrEqualOp
 | lessThanOp
 | greaterThanOp
 | greaterThanOrEqualOp
 | isntOp
 | isOp
 | equalsOp
 | unequalOp
 | subtypeOp

lessThanOp ::= expr LESS_THAN_SYM expr
lessThanOrEqualOp ::= expr LESS_THAN_OR_EQUAL_SYM expr
greaterThanOp ::= expr GREATER_THAN_SYM expr
greaterThanOrEqualOp ::= expr GREATER_THAN_OR_EQUAL_SYM expr
equalsOp ::= expr EQUALS_SYM expr
unequalOp ::= expr UNEQUAL_SYM expr
isOp ::= expr IS_SYM expr
isntOp ::= expr ISNT_SYM expr
subtypeOp ::= expr SUBTYPE_SYM expr

// |>
// level 7
pipeOp ::= expr PIPE_SYM expr

private level8 ::=
   spliceOp
 | quoteOp
 | compoundQuoteOp

spliceOp ::= expr SLICE_SYM
// TODO review if this should be a quoted expression!!! with interpolation
quoteOp ::= COLON_SYM expr
compoundQuoteOp ::= QUOTE_KEYWORD expr+ END_KEYWORD

// + - ⊕ ⊖ ⊞ ⊟ .+ .- | ∪ ∨ $ ⊔
private level9 ::=
   plusOp
 | minusOp
 | bitwiseXorOp

bitwiseXorOp ::= expr (INTERPOLATE_SYM | BITWISE_XOR_SYM) expr
plusOp ::= expr PLUS_SYM expr
minusOp ::= expr MINUS_SYM expr

private level10 ::=
   shlOp
 | shrOp
 | ushrOp
 | transposeOp
 | rangeOp

shrOp ::= expr SHR_SYM expr
ushrOp ::= expr USHR_SYM expr
shlOp ::= expr SHL_SYM expr
transposeOp ::= expr TRANSPOSE_SYM
rangeOp ::= expr COLON_SYM expr

// * / % & ^
private level11 ::=
   multiplyOp
 | divideOp
 | remainderOp
 | bitwiseAndOp
 | inverseDivideOp
 | factoriseOp

multiplyOp ::= expr MULTIPLY_SYM expr
divideOp ::= expr DIVIDE_SYM expr
remainderOp ::= expr REMAINDER_SYM expr
inverseDivideOp ::= expr INVERSE_DIV_SYM expr
factoriseOp ::= expr FACTORISE_SYM expr
bitwiseAndOp ::= expr BITWISE_AND_SYM expr

// // .//
// level 12
fractionOp ::= expr FRACTION_SYM expr

// ^ .^
// level 13
exponentOp ::= expr EXPONENT_SYM expr

// ::
// level 14
typeOp ::= expr DOUBLE_COLON expr

// TODO unfinished
private level15 ::=
   unaryPlusOp
 | unaryMinusOp
 | notOp
 | interpolateOp

unaryMinusOp ::= MINUS_SYM expr
notOp ::= NOT_SYM expr
unaryPlusOp ::= PLUS_SYM expr
interpolateOp ::= INTERPOLATE_SYM expr

private primaryExpr ::=
   string
 | charLit
 | integer
 | floatLit
 | booleanLit
 | macroIdentifier
 | identifier
 | ifExpr
 | forExpr
 | regex
 | byteArray
 | whileExpr
 | function
 | compactFunction
 | empty
 | union
 | macro
 | block
 | abstractTypeDeclaration
 | typeDeclaration
 | typeAlias

private arrayConstructorOp ::= expr LEFT_M_BRACKET RIGHT_M_BRACKET

empty ::= LEFT_M_BRACKET RIGHT_M_BRACKET { extends=expr }
